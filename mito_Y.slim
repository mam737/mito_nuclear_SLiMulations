initialize() {
	if (exists("slimgui"))
	{
	
		// Size of Each Population
		defineConstant("N",1000);

		// Migration Rate Between Populations	
		defineConstant("mig",0.01);

		// Number of Mother's Curse: Restorer Pairs Initially Unique to Each Population	
		defineConstant("MC_R",20);
		
		// Mother's Curse Cost in Males & Advantage in Females	
		defineConstant("MC_del",0.0);
		defineConstant("MC_adv",1.00);

		// Output File Names
		defineConstant("filename1",'/Users/Minie/Desktop/SLiM_Models/test/' + paste(c(MC_R,MC_del,MC_adv),'_') + '_meanfit.txt');
		defineConstant("filename2",'/Users/Minie/Desktop/SLiM_Models/test/' + paste(c(MC_R,MC_del,MC_adv),'_') + '_freqrun.txt');
	}	


	// No New Mutations
	initializeMutationRate(0.0);	
	
	// Size of Mitochondrial and Nuclear Genomic Region
	defineConstant("L_M",2*MC_R);
	defineConstant("L_N",2*MC_R);
	
	
	initializeSex("A");
	
	
	// m1 Pop1 Mother's Curse
	initializeMutationType("m1", 1.0, "f", MC_del);
	m1.convertToSubstitution = F;
	m1.color = 'red';
	
	//m2 Pop1 Nuclear Restorer
	initializeMutationType("m2",0.5,"f",0.0);
	m2.convertToSubstitution = F;
	m2.color = 'limegreen';
	
	//m3 Pop2 Mother's Curse
	initializeMutationType("m3",1.0,"f", MC_del);
	m3.convertToSubstitution = F;
	m3.color = 'blue';
	
	//m4 Pop2 Nuclear Restoer
	initializeMutationType("m4",0.5,"f",0.0);
	m4.convertToSubstitution = F;
	m4.color = 'purple';
	
	//m5 Mitochondrial Marker Mutation
	initializeMutationType('m5',0.5,'f',0.0);
	m5.convertToSubstitution = F;
	m5.color = 'gray60'; 
	
	//m6 Y Chromosome Marker Mutation
	initializeMutationType('m6',0.5,'f',0.0);
	m6.convertToSubstitution = F;
	m6.color = 'gray40';
	
	initializeGenomicElementType('g1',c(m1,m3),c(1.0,1.0));
	initializeGenomicElementType('g2',c(m2,m4),c(1.0,1.0));
	
	initializeMutationRate(0.0);
	initializeGenomicElement(g1,0,2*MC_R);
	initializeGenomicElement(g2,(2*MC_R)+1,4*MC_R+1);

	// Recombination Rate for Nuclear Region
	initializeRecombinationRate(0);
	
	line = paste(c('p1_meanfit','p2_meanfit','avg_meanfit'),'\t');
	writeFile(filename1,line,append=T);
	
	line = paste(c('MutType','Gen','P1_Freq','P2_Freq','Avg_Freq'),'\t');
	writeFile(filename2, line, append=T);

}

// create a population of N individuals
1 late()

{
	sim.addSubpop("p1", N);
	sim.addSubpop("p2", N);
	
	p1.setMigrationRates(p2,mig);
	p2.setMigrationRates(p1,mig);
	
	// Each individual has a haploid mitochondrial genome, designated
	// by the presence of an m5 marker mutation that we add here; these
	// markers are inherited and live forever in the simulation.
	inds = sim.subpopulations.individuals;
	mito = inds.genomes[seqAlong(inds) * 2];
	mito.addNewDrawnMutation(m5, 0);
	
	
	// Every male will also carry a marker denoting which genome
	// is the Y chromosome
	
	males = inds[inds.sex=='M'];
	Y = males.genomes[seqAlong(males)*2+1];
	Y.addNewDrawnMutation(m6,4*MC_R+1);
	
	// Add M1 (Mother's Curse) and M2 (Nuclear Restorer) Mutations to p1
		
	p1_inds = p1.individuals;
	p1_mito = p1_inds.genomes[seqAlong(p1_inds) * 2];
	
	for (i in seq(1,MC_R)) {
		p1_mito.addNewDrawnMutation(m1,i);
	}

	p1_males = p1_inds[p1_inds.sex=='M'];
	p1_Y = p1_males.genomes[seqAlong(p1_males)*2+1];
	
	
	for (i in seq((2*MC_R)+1,3*MC_R)) {
		p1_Y.addNewDrawnMutation(m2,i);
	
	}
	
	// Add M1 (Mother's Curse) and M2 (Nuclear Restorer) Mutations to p2
	
	p2_inds = p2.individuals;
	p2_mito = p2_inds.genomes[seqAlong(p2_inds) * 2];
	
	for (i in seq(MC_R+1,2*MC_R)) {
		p2_mito.addNewDrawnMutation(m3,i);
	}
	
	
	p2_males = p2_inds[p2_inds.sex=='M'];
	p2_Y = p2_males.genomes[seqAlong(p2_males)*2+1]	;
	
	for (i in seq((3*MC_R)+1,4*MC_R)) {
	
		p2_Y.addNewDrawnMutation(m4,i);
		
	}

	// Tag all mutations in Pop 1 such that
	// for each Mother's Curse loci there is 
	// one nuclear restorer loci	
	all_m1 = sim.mutationsOfType(m1);
	all_m1.tag = seq(1,MC_R);

	all_m2 = sim.mutationsOfType(m2);
	all_m2.tag = seq(1,MC_R);

	// For all Mother's Curse variants
	// set the advantage in female		
	for (mut_m1 in all_m1) {
		mut_m1.setValue('f_F',MC_adv);
	}
	

	// For all nuclear restorers
	// set the dominance coefficient 	
	for (mut_m2 in all_m2) {
		mut_m2.setValue("d_M",0.5);
	}

	// Tag all mutations in Pop 2 such that
	// for each Mother's Curse loci there is 
	// one nuclear restorer loci	
		
	all_m3 = sim.mutationsOfType(m3);
	all_m3.tag = seq(MC_R+1,2*MC_R);

	all_m4 = sim.mutationsOfType(m4);
	all_m4.tag = seq(MC_R+1,2*MC_R);

	// For all Mother's Curse variants
	// set the advantage in female	
	for (mut_m3 in all_m3) {
		mut_m3.setValue('f_F',MC_adv);
	}
		

	// For all nuclear restorers
	// set the dominance coefficient 		
	for (mut_m4 in all_m4) {
		mut_m4.setValue('d_M',0.5);
	}
}

modifyChild()
{
	// Each offspring needs to inherit a mitochondrial genome from its
	// female parent, and not inherit one from the male parent.  Note that
	// childGenome1 comes from the first (female parent).  If we wanted to
	// model mitochondria coming from the male parent instead, a small
	// percentage of the time, this is where that would be done.
	if (!childGenome1.containsMarkerMutation(m5, 0))
		return F;

	// Ensure that no female contains a Y chromosome using the m6 marker
	if (child.sex=='F' & childGenome2.containsMarkerMutation(m6,4*MC_R+1)) {
		return F;
	}
	
	// Ensure that every male contains a Y chromosome using the m6 marker
	if (child.sex=='M' & !childGenome2.containsMarkerMutation(m6,4*MC_R+1)) {
		return F;
	}
	// At this point, we have determined that the offspring is valid,
	// having inherited its mitochondrial genome from its mother, and
	// so now we do some cleanup of the genetics of the offspring.
	
	// We enforce haploidy in the mitochondrial genome here, by removing all
	// mutations from the null genome.  This prevents any confusion during
	// during fitness calculations.  This is one reason we use different
	// mutation types for neutral mutations in the two genomes.
	childGenome2.removeMutations(childGenome2.mutationsOfType(m1));
	childGenome2.removeMutations(childGenome2.mutationsOfType(m3));
	childGenome2.removeMutations(childGenome2.mutationsOfType(m5));
		
	return T;
	
}

fitness(m1) 
{
	// OK, so: m3 mutations have different fitness effects in males versus
	// females, and those effects also depend upon whether a compensator
	// for the particular m3 mutation is present in the nuclear genome.
	// So we have, in effect, four basic cases for an m3 mutation:
	//  - in a male, no compensator present
	//  - in a female, no compensator present
	//  - in a male, compensator present
	//  - in a female, compensator present
	// In the present design, the fitness in females is assumed to be the
	// same whether compensators are present or not.  In males, the fitness
	// effect of the compensator depends upon dominance as well; see below.
	
	// So, since the fitness effect in females does not depend upon the
	// presence/absence of compensators, we can deal with them up front.
	if (individual.sex == "F") {
		return mut.getValue("f_F");
	}
	
	// For males, we need to determine how many of restorers they contain
	// for the specific Mother's Cures mutation
	lockShape = mut.tag;
	allCompensators = individual.genomes.mutationsOfType(m2);
	matchCompensators = allCompensators[allCompensators.tag==lockShape];
	keyCount = size(matchCompensators);
	
	if (keyCount == 1)
	{
		// At least two keys are present for the lock mutation, so we consider
		// it to be fully compensated for.  Note that these keys might be two
		// different mutations, each matching this lock, each heterozygous in
		// this individual.  This is by design; it seems like perhaps it makes
		// sense.  But if a different scheme is wanted, it should be possible.
		return 1.0;
	}
	else
	{
		// No compensator ("key") is present.  Given this, if the focal mut is
		// in a male, the effect is given by the m3 mut's selection coefficient,
		// so we use relFitness here.
		if (individual.sex == "M")
			return relFitness;
	}
}

fitness(m3) 
{
	// OK, so: m3 mutations have different fitness effects in males versus
	// females, and those effects also depend upon whether a compensator
	// for the particular m3 mutation is present in the nuclear genome.
	// So we have, in effect, four basic cases for an m3 mutation:
	//  - in a male, no compensator present
	//  - in a female, no compensator present
	//  - in a male, compensator present
	//  - in a female, compensator present
	// In the present design, the fitness in females is assumed to be the
	// same whether compensators are present or not.  In males, the fitness
	// effect of the compensator depends upon dominance as well; see below.
	
	// So, since the fitness effect in females does not depend upon the
	// presence/absence of compensators, we can deal with them up front.
	if (individual.sex == "F")
		return mut.getValue("f_F");

	// For males, we need to determine how many of restorers they contain
	// for the specific Mother's Cures mutation
	lockShape = mut.tag;
	allCompensators = individual.genomes.mutationsOfType(m4);
	matchCompensators = allCompensators[allCompensators.tag==lockShape];
	keyCount = size(matchCompensators);
	
	if (keyCount == 1)
	{
		// At least two keys are present for the lock mutation, so we consider
		// it to be fully compensated for.  Note that these keys might be two
		// different mutations, each matching this lock, each heterozygous in
		// this individual.  This is by design; it seems like perhaps it makes
		// sense.  But if a different scheme is wanted, it should be possible.
		return 1.0;
	}

	else
	{
		// No compensator ("key") is present.  Given this, if the focal mut is
		// in a male, the effect is given by the m3 mut's selection coefficient,
		// so we use relFitness here.
		if (individual.sex == "M")
			return relFitness;
	}
}

early ()
{
	if (sim.generation % 10 == 0) {
		//cat("p1 mean fitness = " + mean(p1.cachedFitness(NULL)) + "\n");
		//cat("p2 mean fitness = " + mean(p2.cachedFitness(NULL)) + "\n");
		
		p1_mean = mean(p1.cachedFitness(NULL));
		p2_mean = mean(p2.cachedFitness(NULL));
		avg_mean = (p1_mean + p2_mean)/2; 
		
		//cat("Avg mean fitness = " + avg_mean + "\n");
		
		line = paste(c(p1_mean,'\t',p2_mean,'\t',avg_mean,'\n'));
		writeFile(filename1, line, append=T);
		
		
		for (i in sim.mutationsOfType(m1)) {
			tag = paste(c("m1",i.tag),"_");
			p1_freq = sim.mutationFrequencies(p1,i);
			p2_freq = sim.mutationFrequencies(p2,i);
			avg_freq = sim.mutationFrequencies(NULL,i);
			
			
			line = paste(c(tag,sim.generation,p1_freq,p2_freq,avg_freq),'\t');
			writeFile(filename2, line, append=T);
		}
		
		for (i in sim.mutationsOfType(m2)) {
			tag = paste(c("m2",i.tag),"_");
			p1_freq = sim.mutationFrequencies(p1,i);
			p2_freq = sim.mutationFrequencies(p2,i);
			avg_freq = sim.mutationFrequencies(NULL,i);
			
			line = paste(c(tag,sim.generation,p1_freq,p2_freq,avg_freq),'\t');
			writeFile(filename2, line, append=T);
		}
		
		for (i in sim.mutationsOfType(m3)) {
			tag = paste(c("m3",i.tag),"_");
			p1_freq = sim.mutationFrequencies(p1,i);
			p2_freq = sim.mutationFrequencies(p2,i);
			avg_freq = sim.mutationFrequencies(NULL,i);
			
			line = paste(c(tag,sim.generation,p1_freq,p2_freq,avg_freq),'\t');
			writeFile(filename2, line, append=T);
		}
		
		for (i in sim.mutationsOfType(m4)) {
			tag = paste(c("m4",i.tag),"_");
			p1_freq = sim.mutationFrequencies(p1,i);
			p2_freq = sim.mutationFrequencies(p2,i);
			avg_freq = sim.mutationFrequencies(NULL,i);
			
			line = paste(c(tag,sim.generation,p1_freq,p2_freq,avg_freq),'\t');
			writeFile(filename2, line, append=T);
		}		
				
	}
}

// output samples of 10 genomes periodically, all fixed mutations at end
1000 late()
{
}
